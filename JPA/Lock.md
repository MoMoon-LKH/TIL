## Lock
    데이터의 일관성을 보장하기 위해 데이터를 보호하는 방법
<br>

#### 문제상황
트랜잭션끼리 영향성을 미치게 되면 동시성의 문제가 발생하게되는데

#### 예를 들어 동시에 1이라는 값에 +1, -1의 요청이 왔다면 <br>
<img src="https://github.com/MoMoon-LKH/GameInfo_Ver2/assets/66755342/4740e488-db66-4898-a6d6-866e4db0f35f" width="300px"/><br>
#### 위처럼 정상값 1이 아닌 0이 업데이트되는 동시성 문제가 발생

<br>

### Lock의 종류
Lock의 종류는 낙관적 락, 비관적 락이 있습니다.

### 1. 비관적 락
- 공유락(Shared Lock): 다른 트랜잭션에서 읽기만 가능
- 베타락(Exclusive Lock): 다른 트랜잭션에서 읽기, 쓰기 불가능
- 하나의 트랜잭션이 read한 시점에서 위의 공유락 또는 베타락을 거는 방식
#### ex) 동시에 요청했다면
     1) 처음 들어온 update가 read한 시점에서 lock
     2) 처음 들어온 요청이 끝날 때까지 다른 update 요청은 대기
     3) 처음 들어온 요청이 끝났다면 나중에 들어온 요청 처리

##### 데드락
- 비관적 락일 경우 데드락이 발생될 가능성이 있음
- 두 쓰레드가 작업을 끝낼 수 없는 교착상태
##### ex)
      1) 1번 쓰레드: row A read 후 잠금
      2) 2번 쓰레드: row B read 후 잠금
      3) 1번 쓰레드: row B read 시 접근 불가능
      4) 2번 쓰레드: row A read 시 접근 불가능
      위와 같은 경우는 최대 잠금 시간을 지정하여 처리


### 2. 낙관적 락 (JPA, 어플리케이션 단에서 처리)
- 동시성이 발생하면 그때 처리하는 방식
- @Version 어노테이션이 붙은 컬럼을 통해 동시성을 확인합니다
#### ex) version = 1 인 상태로 동시에 요청하였다면
       1) 처음 들어온 update가 version를 +1 한 상태인 2로 같이 업데이트
       2) 나중에 들어온 update는 version이 2로 업데이트가 되었기때문에 실패하고 롤백하고 충돌 예외 발생
       -> @Version이라는 구분 컬럼을 통해 충돌을 방지합니다
       
       이 경우는 2)의 트랜잭션를 다시 요청하거나 예외 처리 
<br>


#### 2023-07-13